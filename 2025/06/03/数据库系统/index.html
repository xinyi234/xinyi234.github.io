<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库系统 | Xinyi's blog</title><meta name="author" content="xinyi"><meta name="copyright" content="xinyi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库参考https:&#x2F;&#x2F;superpung.notion.site&#x2F;6c01057bb5c4474d9849b9df8e759bc1 2025.6.19 呜呜呜考的好烂😫下次一定好好复习）索引查询代价一定要看 关系数据模型数据库是长期存储在计算机内，有组织的，可共享的数据的集合 DBMS是用户与操作系统之间的一层数据管理软件 事务处理的ACID性质：原子性，一致性，独立性，持久性 sql基本语">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库系统">
<meta property="og:url" content="https://xinyi234.github.io/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Xinyi&#39;s blog">
<meta property="og:description" content="数据库参考https:&#x2F;&#x2F;superpung.notion.site&#x2F;6c01057bb5c4474d9849b9df8e759bc1 2025.6.19 呜呜呜考的好烂😫下次一定好好复习）索引查询代价一定要看 关系数据模型数据库是长期存储在计算机内，有组织的，可共享的数据的集合 DBMS是用户与操作系统之间的一层数据管理软件 事务处理的ACID性质：原子性，一致性，独立性，持久性 sql基本语">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xinyi234.github.io/img/gudu1.png">
<meta property="article:published_time" content="2025-06-03T06:06:11.000Z">
<meta property="article:modified_time" content="2025-06-19T08:26:00.420Z">
<meta property="article:author" content="xinyi">
<meta property="article:tag" content="复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xinyi234.github.io/img/gudu1.png"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://xinyi234.github.io/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: '[object Object]',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #efefef;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/gudu1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/head.jpg" alt="Logo"><span class="site-name">Xinyi's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">数据库系统</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据库系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-03T06:06:11.000Z" title="发表于 2025-06-03 14:06:11">2025-06-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-19T08:26:00.420Z" title="更新于 2025-06-19 16:26:00">2025-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0/">复习</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>参考<a target="_blank" rel="noopener" href="https://superpung.notion.site/6c01057bb5c4474d9849b9df8e759bc1">https://superpung.notion.site/6c01057bb5c4474d9849b9df8e759bc1</a></p>
<p>2025.6.19</p>
<p>呜呜呜考的好烂😫下次一定好好复习）索引查询代价一定要看</p>
<h2 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h2><p>数据库是长期存储在计算机内，有组织的，可共享的数据的集合</p>
<p>DBMS是用户与操作系统之间的一层数据管理软件</p>
<p>事务处理的ACID性质：原子性，一致性，独立性，持久性</p>
<p>sql基本语法：</p>
<p>创建数据库：CREATE DATABASE 数据库名；</p>
<p>删除数据库：DROP DATABASE 数据库名；</p>
<p>一个数据模型包括结构，操作，约束三部分</p>
<p>Schema:关系(属性) ex:Movies(title,year,genre)</p>
<p>Tuple:关系的一行，包括每个属性 ex: (star,1979,comedy)</p>
<p>Domain: 与关系的每个属性相关 ex: Movies(title:string,year:integer,genre:string)</p>
<p>关系的键Key</p>
<p>表声明：</p>
<p>CREATE TABLE movieexec (<br>    name CHAR(30),<br>    address VARCHAR(255),<br>    cert INT PRIMARY KEY, &#x2F;&#x2F; 主键<br>    networth INT,<br>    FOREIGN KEY (attributeName) REFERENCES tableName(attributeName) &#x2F;&#x2F; 外键，参照完整性<br>    PRIMARY KEY (), &#x2F;&#x2F; 实体完整性<br>);</p>
<p>sql数据类型：</p>
<p>CHAR(n) 长度为n的定长字符串</p>
<p>VARCHAR(n) 最大长度为n的变长字符串</p>
<p>INT 长整数</p>
<p>REAL 浮点数</p>
<p>BIT(n) 固定长度位串</p>
<p>BIT VARYING(n) 可变长度位串</p>
<p>DECIMAL(n,d)</p>
<p>DATE</p>
<p>TIME</p>
<p>实体完整性要求关系表的<strong>主键（Primary Key）不能为空值（NULL）</strong>，而且<strong>每一行的主键值必须唯一</strong>。</p>
<p><strong>定义</strong>：参照完整性约束用于维护<strong>外键（Foreign Key）与主键之间的依赖关系</strong>，要求外键的值要么为 NULL，要么必须对应主键表中的某个已有值。</p>
<p>插入数据：INSERT INTO 表名 VALUES ( );</p>
<p>查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列（属性）表达式<span class="operator">&gt;</span>[, <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>...]</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表（关系）名或视图名<span class="operator">&gt;</span>[, <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>...]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;&gt;</span>]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure>

<p>order by排序 ORDER BY 列名 [ASC|DESC];</p>
<p>group by对查询结果进行分组，<code>HAVING</code> 是对<strong>分组之后的结果</strong>筛选，在 SQL 中使用 <code>GROUP BY</code> 时，<strong>SELECT 子句中除聚合函数外的字段，必须全部出现在 <code>GROUP BY</code> 后面</strong>，这是为了保证分组后的查询结果是<strong>逻辑一致且可计算的</strong>。</p>
<p>修改关系模式</p>
<p>DROP TABLE R;</p>
<ul>
<li><code>ALTER TABLE tableName ADD attributeName TYPE(n);</code>（添加属性）</li>
<li><code>ALTER TABLE tableName DROP attributeName;</code>（删除属性）</li>
<li><code>ALTER TABLE tableName ADD attributeName TYPE(n) DEFAULT ‘defaultValue’;</code>（添加有默认值的属性）</li>
</ul>
<p>default values 默认值</p>
<p>&#96;ALTER TABLE tableName ADD attributeName TYPE(n) DEFAULT ‘haha’;</p>
<h2 id="关系数据库语言"><a href="#关系数据库语言" class="headerlink" title="关系数据库语言"></a>关系数据库语言</h2><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>Set operations : Union,Intersection, Difference</p>
<p>SELECT * FROM R UNION SELECT * FROM S;</p>
<p>SELECT * FROM R INTERSECT SELECT * FROM S;</p>
<p>SELECT * FROM R EXCEPT SELECT * FROM S;</p>
<p>Projection 投影 选择关系中的几个属性</p>
<p>SELECT [DISTINCT] genre FROM movies;</p>
<p>Selection选择 选择符合条件的关系</p>
<p>SELECT * from movies where length&gt;100;</p>
<p>Cartesian Product笛卡尔积 RxS</p>
<p>SELECT * FROM R CROSS JOIN S;或SELECT * FROM R,S;</p>
<p>Natural join自然连接R\Join S  等价于从二者的笛卡尔积中选择出属性值相同的元组，再投影出属性集相并后的关系</p>
<p>SELECT * FROM U NATURAL INNER JOIN V;</p>
<p>Theta-join theta连接 等价于从二者的笛卡尔积中选择出一定条件的元组</p>
<p>SELECT * FROM U INNER JOIN V ON a&gt;d;</p>
<p>重命名 rename \rho 将R的属性重命名为S的</p>
<p>Division 除法 找出所有在 R 中，<strong>对 S 中所有 B 都有关联</strong>的 A。</p>
<p>仅有的冗余：</p>
<ul>
<li>交 &#x3D; 差差</li>
<li>Theta 连接 &#x3D; 笛卡尔积的选择</li>
<li>自然连接 &#x3D; Theta 连接的投影</li>
</ul>
<p>LIKE模糊匹配字符串，%匹配<strong>任意长度</strong>的任意字符（包括 0 个），_匹配任意一个字符</p>
<p>NULL的规定：</p>
<ul>
<li>任何数与NULL运算结果都是NULL</li>
<li>任何数与NULL比较结果都是UNKNOWN</li>
<li>IS NULL操作</li>
</ul>
<p>TRUE表示1，FALSE表示0，UNKOWN表示1&#x2F;2</p>
<h3 id="Subquery子查询"><a href="#Subquery子查询" class="headerlink" title="Subquery子查询"></a>Subquery子查询</h3><p>子查询是另一个查询的一部分，子查询可以嵌套</p>
<p>SELECT name FROM MovieExec WHERE cert &#x3D; (SELECT * FROM Movies WHERE title &#x3D; ‘Star Wars’)；</p>
<p>SQL operators</p>
<p>s IN R</p>
<p>s &gt; ALL R</p>
<p>s&lt; ANY R</p>
<p><img src="/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/image-20250603171506054.png" alt="image-20250603171506054"></p>
<p>聚合函数 COUNT，SUM，AVG,MAX,MIN</p>
<h3 id="Modification"><a href="#Modification" class="headerlink" title="Modification"></a>Modification</h3><p>INSERT INTO R(A1, …, An) VALUES (v1, …, vn);</p>
<p>DELETE FROM R WHERE 条件;</p>
<p>UPDATE R SET 新值 WHERE 条件</p>
<h2 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h2><h3 id="函数依赖FD"><a href="#函数依赖FD" class="headerlink" title="函数依赖FD"></a>函数依赖FD</h3><p>用于描述表中属性（列）之间的<strong>逻辑关系</strong>，对理解<strong>范式（如第三范式）和规范化</strong>非常重要。</p>
<p>在关系 R 中，若对于任意两个元组（行） t1 和 t2：<br>如果 t1[A] &#x3D; t2[A]，那么必有 t1[B] &#x3D; t2[B]，<br>就说 <strong>属性集 A 函数决定属性集 B</strong>，记作A-&gt;B</p>
<p>R 满足函数依赖 F：</p>
<ul>
<li>确定关系 R 的每个实例都能使一个给定的 FD F 为真</li>
<li>作用：在 R 上声明了一个约束，而不是仅针对 R 的一个实例</li>
</ul>
<p>关系的键：一组属性决定了该关系的其他所有属性，键是最小集合</p>
<p>有时一个关系可能会有多个键，通常需要指定其中一个为主键primary key</p>
<p>超键Superkey：一个包含键的属性的集合</p>
<p>等价 Equivalent：如果满足 FD S 的关系实例的集合和满足 FD T 的关系实例的集合相同，则 S 和 T 等价</p>
<p>推断 Follows：如果满足 FD T 的所有关系实例也满足 FD S，则 T 可以推断出 S（S follows from T）</p>
<p>规则：</p>
<ul>
<li>分解规则 Splitting rule：A1A2…An → B1B2…Bm 等价于 A1A2…An → Bi，i &#x3D; 1,2,…,m</li>
<li>组合规则 Combining rule：A1A2…An → Bi，i &#x3D; 1,2,…,m 等价于 A1A2…An → B1B2…Bm</li>
<li>注意：左侧不能分解</li>
</ul>
<p>平凡函数依赖：关系上的一个约束对所有关系实例都成立，且与其他约束无关，则这个约束就是平凡的，一个属性集可以函数决定它的子集</p>
<p><img src="/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/image-20250603174828539.png" alt="image-20250603174828539"></p>
<p><strong>候选键</strong>是指：能唯一标识元组（记录），并且<strong>没有冗余</strong>的属性集合，能推出其他所有属性</p>
<p>计算属性的闭包</p>
<p>X+&#x3D;在依赖集 F 中，所有能由 X 推导出的属性集合</p>
<p>计算方法：</p>
<ol>
<li>初始化：令 X+:&#x3D;XX^+ :&#x3D; XX+:&#x3D;X</li>
<li>重复以下步骤直到不再变化：对于依赖 Y→Z∈FY \to Z \in FY→Z∈F，如果 Y⊆X+Y \subseteq X^+Y⊆X+，则将 ZZZ 加入 X+X^+X+</li>
</ol>
<p>传递规则：属性集 A 函数决定属性集 B，属性集 B 函数决定属性集 C，则属性集 A 函数决定属性集 C</p>
<p>最小基本集：它是函数依赖集的一个<strong>等价表示</strong>，但去除了冗余，更便于分析候选键、范式分解等</p>
<ol>
<li>最小基本集中所有 FD 右侧只有一个属性</li>
<li>从最小基本集中删除任何一个 FD，它不再是基本集</li>
<li>删除其中一个 FD 左侧的一个或多个属性，它不再是基本集</li>
</ol>
<p>ArmStrong公理：用于推导出所有隐含的函数依赖</p>
<p>1.自反性：如果 Y⊆X，则 X→Y</p>
<p>2.增广性：如果 X→Y，则 XZ→YZ</p>
<p>3.传递性：如果 X→Y,Y→Z，则 X→Z</p>
<p>函数依赖集的投影：在一个关系 R 上存在一个函数依赖集 F，如果我们从 R 投影出一个子关系 S（属性子集），那么我们要找出在这个 S 上<strong>仍然成立</strong>的那些函数依赖</p>
<p><img src="/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/image-20250603195129643.png" alt="image-20250603195129643"></p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>为了解决数据库设计不规范造成的冗余，更新异常，删除异常</p>
<p>分解关系：</p>
<p>分解 Decomposition：给定关系 R(A1,A2,…,An)，分解为 S(B1,B2,…Bm) 和 T(C1,C2,…,Ck) 满足：</p>
<ol>
<li>{A1,A2,…An} &#x3D; {B1,B2,…,Bm} $\cup$ {C1,C2,…,Ck}</li>
<li>$S &#x3D; \pi_{B_1,B_2,…,B_m}(R)$</li>
<li>$T &#x3D; \pi_{C_1,C_2,…,C_k}(R)$</li>
</ol>
<p>BC 范式 Boyce-Codd Normal Form，BCNF：每个非平凡FD的左侧必须是R的超键或者没有非平凡FD</p>
<p>任意一个二元关系都属于 BCNF</p>
<p>如何把关系分解为BCNF:</p>
<p>找到违反 BCNF 的依赖 <code>X → A</code>（X 不是候选键）</p>
<p>分解原关系 R 为两个关系：</p>
<ul>
<li>一个关系：<code>X ∪ A</code></li>
<li>另一个关系：<code>R - A</code>（但保留 X）</li>
</ul>
<p>重复以上过程，直到所有子关系都满足 BCNF</p>
<p>一道例题：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_69884785/article/details/131377341">https://blog.csdn.net/weixin_69884785/article/details/131377341</a></p>
<p>好的分解：</p>
<ul>
<li>消除异常</li>
<li>可恢复信息</li>
<li>保持依赖</li>
</ul>
<p>Lossless join无损连接</p>
<p>依照上述 BCNF 分解算法分解关系，则可以通过自然连接得到初始关系：</p>
<ul>
<li>属性集 X、Y、Z</li>
<li>如果 R 有 FD Y → Z，且 R 的属性集为 $X\cup Y\cup Z$</li>
<li>则 $R &#x3D; \pi_{X\cup Y}(R)\Join\pi_{Y\cup Z}(R)$</li>
</ul>
<p>无损连接的chase检验</p>
<p>假设关系 R 的属性为 {A, B, C, …}，分解成子关系 R₁, R₂, …，我们用一个表格模拟元组，跟踪属性值的变换</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_56462041/article/details/130225013">https://blog.csdn.net/weixin_56462041/article/details/130225013</a></p>
<p>dependancy preservation保持依赖</p>
<p> BCNF 分解后的关系，无法同时具有无损连接和依赖保持的性质</p>
<p>第三范式：</p>
<ul>
<li>对于每个非平凡 FD A1A2…An → B1B2…Bm，要么属性集 A 是超键，要么 B - A 是主属性</li>
<li>对于每个非平凡 FD，或者其左侧是超键，或者其右侧仅由主属性构成，主属性是键的成员，无传递依赖</li>
</ul>
<p>3NF分解步骤</p>
<p>第一步：为每个函数依赖创建关系模式</p>
<ol>
<li>R₁(A,B,C,D) —— 由AB→CD</li>
<li>R₂(A,E) —— 由A→E</li>
<li>R₃(B,F,H) —— 由B→FH</li>
<li>R₄(C,G) —— 由C→G</li>
<li>R₅(D,B) —— 由D→B</li>
<li>R₆(G,C) —— 由G→C</li>
<li>R₇(H,I) —— 由H→I<br>第二步：合并相同左部的关系</li>
</ol>
<p>合并R₄和R₆（都基于C和G）：</p>
<ul>
<li>R₄’(C,G) —— 合并C→G和G→C</li>
</ul>
<p>第三步：检查候选键是否被包含</p>
<p>候选键是AB，已包含在R₁中</p>
<p>第四步：最终3NF分解</p>
<ol>
<li>R₁(A,B,C,D) —— {AB→CD}</li>
<li>R₂(A,E) —— {A→E}</li>
<li>R₃(B,F,H) —— {B→F, B→H}</li>
<li>R₄’(C,G) —— {C→G, G→C}</li>
<li>R₅(D,B) —— {D→B}</li>
<li>R₇(H,I) —— {H→I}</li>
</ol>
<p>验证无损连接性</p>
<p>使用Chase算法验证：</p>
<ul>
<li><p>初始表：</p>
<p>Copy</p>
<p>Download</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">R₁: A B C D a e1 f1 g1 h1 i1</span><br><span class="line">R₂: A a B1 C1 D1 E a f1 g1 h1 i1</span><br><span class="line">R₃: A1 B a C1 D1 E1 F a H a I1</span><br><span class="line">R₄&#x27;: A1 B1 C a D1 E1 F1 G a H1 I1</span><br><span class="line">R₅: A1 B a C1 D a E1 F1 G1 H1 I1</span><br><span class="line">R₇: A1 B1 C1 D1 E1 F1 G1 H a I a</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过应用函数依赖可以推导出所有属性都有”a”，证明分解是无损的</p>
</li>
</ul>
<p> 验证依赖保持性</p>
<p>检查原始F中的每个依赖：</p>
<ol>
<li>AB→CD：由R₁保持</li>
<li>A→E：由R₂保持</li>
<li>B→FH：由R₃保持</li>
<li>C→G：由R₄’保持</li>
<li>D→B：由R₅保持</li>
<li>G→C：由R₄’保持</li>
<li>H→I：由R₇保持</li>
</ol>
<p>所有依赖都被保持</p>
<p>最终3NF分解结果</p>
<p>ρ &#x3D; {<br>R₁(A,B,C,D),<br>R₂(A,E),<br>R₃(B,F,H),<br>R₄’(C,G),<br>R₅(D,B),<br>R₇(H,I)<br>}</p>
<p>第一范式 First Normal Form，1NF：每个属性的值是原子值、有键。</p>
<p>第二范式 Second Normal Form，2NF：所有非主属性都被主键函数决定，不能被主键的一部分决定。</p>
<h3 id="多值依赖MVD"><a href="#多值依赖MVD" class="headerlink" title="多值依赖MVD"></a>多值依赖MVD</h3><ul>
<li>两个属性或属性集合相互独立的断言</li>
<li>广义的函数依赖</li>
</ul>
<p>在固定 X 的值时，Y 的所有可能取值集合，与 R 中其他属性无关,则X-&gt;-&gt;Y</p>
<p>定义：</p>
<ul>
<li>MVD A1A2…An →→ B1B2…Bm 指 B 的值与 R 中不在 A 和 B 中的属性是独立的</li>
<li>对于 R 中每个在所有 A 属性上一致的元组对 t 和 u，能在 R 中找到满足下列条件的元组 v：<ol>
<li>在 A 属性上的取值与 t 和 u 相同</li>
<li>在 B 属性上的取值与 t 相同</li>
<li>在 R 中不属于 A 和 B 的所有其他属性上的取值与 u 子相同</li>
</ol>
</li>
<li>(x, y, z)：x →→ y、x →→ z，r 中存在 (a, b, c) 和 (a, d, e)，则 r 中也存在 (a, b, e) 和 (a, d, c)</li>
</ul>
<p>平凡MVD:A1A2…An →→ B1B2…Bm（{B_1,B_2,…,B_m}\subseteq{A_1,A_2,…,A_m}</p>
<p>MVD满足传递规则，但不满足分解规则和组合规则</p>
<p>每个FD都是MVD</p>
<p>互补规则：如果 A1A2…An →→ B1B2…Bm 是关系 R 中的 MVD，则 R 也满足 A1A2…An →→ C1C2…Ck（C 是 R 中除 A 和 B 外的属性集）</p>
<p>4NF范式：对于每个非平凡 MVD A1A2…An →→ B1B2…Bm，{A1, A2, …, An} 都是超键</p>
<p>4NF分解算法：</p>
<p>1.初始化\rho&#x3D;{R}</p>
<p>2.如果\rho的所有模式Ri都满足4NF,转4</p>
<p>3.如果\rho中有一个关系模式S不是4NF,则S中一定有一个多值依赖X-&gt;-&gt;Y且X不包含S的超键，S-Y-X不等于空集，XY不等于S,令Z&#x3D;S-X-Y,设S1&#x3D;XZ,S2&#x3D;S-Z,用分解{S1，S2}代替S,由于S1交S2&#x3D;X,S1-S2&#x3D;Z,所以有(S1交S2)-&gt;-&gt;(S1-S2),分解具有无损连接性，接2</p>
<p>4.分解结束</p>
<h2 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h2><p>entity-relationship model</p>
<p>数据库设计阶段：思考 → 高级设计 → 关系数据库模式 → 关系 DBMS</p>
<h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E&#x2F;R图"></a>E&#x2F;R图</h3><p>Entity Sets 实体集：实体 entity 是某种抽象对象，相似实体的集合形成实体集,E&#x2F;R 图中用矩形表示</p>
<p>Attributes属性：实体集中实体具有的属性，E&#x2F;R图中用椭圆表示，主键加下划线</p>
<p>Relationship联系：多个实体集的连接，E&#x2F;R图中用菱形表示</p>
<p>联系的度：联系实体集的数量</p>
<p>二元E&#x2F;R联系的多样性：</p>
<ul>
<li>一对一：R 既是 E 到 F 的多对一联系，又是 F 到 E 的多对一联系</li>
<li>一对多：F 到 E 是多对一联系，则 E 到 F 是一对多联系</li>
<li>多对一：E 中任一实体与 F 中至多一个实体联系</li>
<li>多对多：R 既不是 E 到 F 的多对一联系，又不是 F 到 E 的多对一联系</li>
</ul>
<p>设计原则：忠实性，避免冗余，简单性</p>
<p>E&#x2F;R模型的约束</p>
<p>键：每个实体集都必须有一个键，通常选择其中一个键为主键，用下划线标识</p>
<p>参照完整性：箭头表示从E到F的多对一关系，F中的实体必须存在</p>
<p>度约束：边上加数字，约束实体联系的数量</p>
<p>弱实体集：一个实体集键由另一个实体集的部分或全部属性构成，一些实体不能独立存在，弱实体集是指依赖于其他实体集的实体集合。它们没有自己的唯一标识符，只能通过与其相关联的其他实体集来进行识别和区分</p>
<p>弱实体集表示法：双边框的矩形，其多对一的关系显示为双边框的菱形</p>
<h2 id="约束与触发器"><a href="#约束与触发器" class="headerlink" title="约束与触发器"></a>约束与触发器</h2><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>约束：数据库强制施加在表字段（列）上的<strong>规则</strong>，用来限制插入、更新或删除的数据必须符合某种要求</p>
<p>主键约束（PRIMARY KEY):主键 &#x3D; NOT NULL + UNIQUE，唯一标识一行</p>
<p>外键约束（FOREIGN KEY):外键，引用另一个表的主键，保持参照完整性,被参照的属性必须是主键或 Unique</p>
<p>对于被引用表的值的修改，引用表有三种处理方式：</p>
<p>默认：拒绝修改</p>
<p>casecade：引用表作同样修改</p>
<p>Set NULL:把引用表的值改为NULL</p>
<p>唯一约束（UNIQUE):所有值必须唯一</p>
<p>非空约束（NOT NULL):不允许为NULL,外键更新的方案 1 不可行、Set NULL 策略不可行</p>
<p>声明外键时可以指定策略：属性后跟 ON [UPDATE, DELETE] [SET NULL, CASCADE]</p>
<p>CHECK:自定义条件约束</p>
<p>DEFAULT:指定默认值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student (</span><br><span class="line">    student_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">CHECK</span> (age <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    class_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (class_id) <span class="keyword">REFERENCES</span> Class(class_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>循环约束条件</p>
<p>延迟约束检查：在参照的属性中插入或更新值，这个值不在被参照的属性中，有三种解决方案：</p>
<ul>
<li>先插入其他属性值，参照属性值置空，再在被参照的关系中插入新的元组包含值，最后更新参照的属性值（问题是参照的属性不能被其他属性参照，而且不能有非空约束）</li>
<li>先在被参照的关系中插入，再在参照的关系中插入（问题是两个关系不能存在循环约束）<ul>
<li>循环约束 circular constraints：不能通过改变顺序解决，不能插入新值</li>
</ul>
</li>
<li>延迟检查：将两个插入组成事务，告知 DBMS 直到整个事务完成要提交时再检查约束</li>
</ul>
<p>延迟检查声明：外键后跟<code>DEFERRABLE INITIALLY DEFERRED</code>在每个事务提交之前检查</p>
<p><code>DEFERRABLE INITIALLY IMMEDIATE</code>每条语句之后检查，与not deferrable相同，但是可以修改延迟状态</p>
<p>SET CONSTRAINTS myconstraint DEFERRED;</p>
<p>  NOT DEFERRABLE（默认）数据库修改语句执行，立即检查约束</p>
<p>基于属性的check约束：属性后面跟check条件，presc INT, CHECK (presc IN (SELECT cert FROM movieExec))</p>
<p>基于元组的check约束：触发条件更强、更频繁，对元组的任意属性的修改都会触发</p>
<ul>
<li>如果约束涉及元组的多个属性，则必须是基于元组的约束</li>
<li>如果约束仅涉及元组的一个属性，则二者都可</li>
</ul>
<p>修改约束：</p>
<p>给约束命名：</p>
<ul>
<li><code>CONSTRAINT 约束名 约束</code></li>
</ul>
<p>修改约束：</p>
<ul>
<li><code>SET CONSTRAINT 约束名 DEFERRED 或 IMMEDIATE</code></li>
<li><code>ALTER TABLE 关系名 DROP CONSTRAINT 约束名</code></li>
<li><code>ALTER TABLE 关系名 ADD CONSTRAINT 约束名</code></li>
</ul>
<p>断言：数据库模式的元组，像关系和视图一样</p>
<p>CREATE ASSERTION 断言名 CHECK 条件，条件可以引用数据库模式的任何关系或属性，断言是一个布尔值的 SQL 表达式，必须一直为真</p>
<p>删除：DROP ASSERTION 断言名</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>只有特定事件发生时才被激活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名</span><br><span class="line">[BEFORE|AFTER] [INSERT|UPDATE|DELETE] OF tablename ON attribute</span><br><span class="line">REFERENCTING</span><br><span class="line">OLD ROW AS oldname,NEW ROW AS newname</span><br><span class="line">FOR EACH ROW（只对每个修改的行执行一次）</span><br><span class="line">WHEN 条件</span><br><span class="line">操作</span><br></pre></td></tr></table></figure>

<ul>
<li>行级触发器 row-level：一次只对一个元组</li>
<li>语句级触发器 statement-level：一次针对 SQL 语句中被改变的所有元组</li>
</ul>
<h2 id="视图和索引"><a href="#视图和索引" class="headerlink" title="视图和索引"></a>视图和索引</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在表或其他视图上的查询所定义的一种关系，分为虚拟视图和物化视图（materialized ）</p>
<p>声明：CREATE [MATERIALIZED] VIEW 视图名 AS 查询，默认为虚拟视图</p>
<p>可以像查询基本表一样查询视图。</p>
<p>有些时候可以对视图进行插入删除更新操作</p>
<p>删除：DROP VIEW 视图名</p>
<p>DROP TABLE 表名（视图不可用）</p>
<p>可更新视图</p>
<p>前提：</p>
<ul>
<li>从一个基本表 R 中 SELECT 一些属性</li>
<li>WHERE 子句在子查询中不能使用关系 R</li>
<li>FROM 子句只能包含 R，不能有其他关系</li>
<li>SELECT 足够多的属性</li>
</ul>
<p>更新视图的影响：</p>
<ul>
<li>视图中插入：在基本表中插入，视图中没有的属性用 NULL</li>
<li>视图中删除：从基本表中删除，须同时满足视图中删除的条件和定义视图的条件</li>
<li>视图中更新：在基本表中更新，须同时满足视图中更新的条件和定义视图的条件</li>
</ul>
<p>视图中的触发器：在视图上定义触发器，用 INSTEAD OF，将那些对视图进行更改的操作，替换为在基本表上的合适的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER para</span><br><span class="line">INSTEAD OF INSERT ON Movies</span><br><span class="line">REFERENCING</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>index：用来加速访问关系中的元组的数据结构，提高在属性 A 上查找具有某个特定值的元组的效率，可以是哈希表，但在 DBMS 中是 B-树，一种广义上的平衡二叉树</p>
<p>声明：CREATE INDEX 索引名 ON 关系名(属性名)，属性可以有多个，有顺序</p>
<p>删除：DROP INDEX 索引名</p>
<p>索引的选择</p>
<p>选择一组值创建索引，索引会使给关系的插入删除更新操作复杂耗时</p>
<p>最有效的索引是键的索引</p>
<p>物化视图：如果某个视图频繁使用，将它实体化效率更高</p>
<h2 id="服务器和安全"><a href="#服务器和安全" class="headerlink" title="服务器和安全"></a>服务器和安全</h2><h3 id="三层体系结构"><a href="#三层体系结构" class="headerlink" title="三层体系结构"></a>三层体系结构</h3><p>通用的体系结构：</p>
<ol>
<li>Web 服务器：连接客户端与数据库系统</li>
<li>应用服务器：执行交易逻辑</li>
<li>数据库服务器：运行 DBMS 并且执行应用服务器请求的查询和更新</li>
</ol>
<h3 id="PSM"><a href="#PSM" class="headerlink" title="PSM"></a>PSM</h3><p>持久性存储模块 PSM &#x3D; 其他语句（if、while 等）和 SQL 的混合</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE &lt;name&gt; (</span><br><span class="line">&lt;parameter list&gt;)</span><br><span class="line">optional local declaration</span><br><span class="line">body;</span><br><span class="line">CREATE FUNCTION &lt;name&gt; (</span><br><span class="line">&lt;parameter list&gt;) RETURNS &lt;type&gt;</span><br><span class="line">optional local declaration</span><br><span class="line">body;</span><br></pre></td></tr></table></figure>

<p>局部声明：<code>DECLARE 变量名 类型 默认值</code></p>
<p>参数：模式-名称-类型三元组：</p>
<ul>
<li>模式 mode：IN、OUT、INOUT</li>
</ul>
<p>调用：CALL 存储过程名 (参数列表)</p>
<p>条件语句，循环语句等语法</p>
<p>cursor</p>
<h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><p>SQL 识别更详细的权限集，在关系上，一共 9 种：</p>
<ol>
<li><code>SELECT [on relation | attributes list]</code> 查询的权限</li>
<li><code>INSERT [on relation | attributes list]</code> 插入元组的权限</li>
<li><code>DELETE</code> 删除元组的权限</li>
<li><code>UPDATE [on relation | attributes list]</code> 更新元组的权限</li>
<li><code>REFERENCE [on relation | attributes list]</code> 被约束引用的权限</li>
<li><code>USAGE [模式元素 除了关系和断言]</code> 在自己的声明中使用这个元素的权限</li>
<li><code>TRIGGER [on relation]</code> 在关系上定义触发器的权限</li>
<li><code>EXECUTE</code> 执行代码的权限，例如 PSM 存储过程或函数</li>
<li><code>UNDER</code> 在给定类型创建子类型的权限</li>
</ol>
<p>授予权限：GRANT &lt;权限列表&gt;<br>ON &lt;关系名或视图名&gt;<br>TO &lt;用户或角色列表&gt;;</p>
<p>在默认方式下，被授予权限的用户&#x2F;角色无权把得到的权限再授予给另外的用户&#x2F;角色。</p>
<p>GRANT &lt;权限列表&gt;<br>ON &lt;关系名或视图名&gt;<br>TO &lt;用户或角色列表&gt;<br>WITH GRANT&#x2F;ADMIN OPTION;</p>
<p>加上 <code>WITH GRANT OPTION</code>，表示被授权的用户可以<strong>把这个权限再授权给其他人</strong>。</p>
<p>收回权限：REVOKE &lt;权限列表&gt;<br>ON &lt;关系名或视图名&gt;<br>FROM &lt;用户或角色列表&gt;;</p>
<p>假如超级管理员U1授权给U2，U2又授权给U3，U3又授权给了U4，当U1要收回U2的授权时，U3和U4的授权也被收回。这种从一个用户&#x2F;角色收回权限可能导致其他用户&#x2F;角色也失去该权限，这一行为称作级联收回。</p>
<p>对于使用with admin option授予权限的用户，系统收回其权限时，不会级联收回。</p>
<ul>
<li><code>CASCADE</code>：收回权限时也要收回那些仅仅由于要收回权限而被授予的权限</li>
<li><code>RESTRICT</code>：如果权限被传递给其他人，收权语句不执行</li>
</ul>
<p>授权图</p>
<p>AP表示授权ID A有权限P,AP*表示有授权选项，AP**表示A是权限P的属主</p>
<p>当 A 授权 P 给 B，则在 AP* 或 AP** 到 BP 间画一条边（如果有授权选项，则是 BP*）</p>
<p>基本规则：用户 C 有权限 Q，只要从 XP** 到 CQ&#x2F;CQ*&#x2F;CQ** 有边，且 P 是 Q 的父权限。（P 可能是 Q，X 可能是 C）</p>
<p>A 级联收回 B 的 P 权限，则删除从 AP 到 BP 的边。</p>
<p>A RESTRICT 收回 B 的 P 权限，且 BP 有出发的边，则拒绝收权，无事发生。</p>
<h2 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>显式定义：</p>
<ul>
<li><code>BEGIN TRANSACTION 语句 COMMIT</code>：提交，事务正常结束</li>
<li><code>BEGIN TRANSACTION 语句 ROLLBACK</code>：回滚到事务开始时状态，事务非正常结束</li>
</ul>
<p>隐式定义：</p>
<ul>
<li>每一个查询或更新语句都是一个事务</li>
</ul>
<p>提交 COMMIT：</p>
<ul>
<li>事务完成</li>
<li>数据库更新将永久保存</li>
</ul>
<p>回滚 ROLLBACK：</p>
<ul>
<li>事务 abort</li>
<li>对数据库没有影响</li>
<li>举例：除以 0、违反约束</li>
</ul>
<p>原语操作：</p>
<p>x 是数据库元素</p>
<ul>
<li>INPUT(x)：将包含 x 的磁盘块拷贝到内存缓冲区</li>
<li>OUTPUT(x)：将包含 x 的缓冲区拷贝回磁盘</li>
<li>READ(x,t)：将内存缓冲区的 x 拷贝到事务的局部变量 t</li>
<li>WRITE(x,t)：将局部变量 t 的值拷贝到内存缓冲区的 x</li>
</ul>
<h3 id="undo-logging"><a href="#undo-logging" class="headerlink" title="undo logging"></a>undo logging</h3><p>保证事务原子性（整体被执行&#x2F;不执行）的一种方法</p>
<p>在系统故障之前，通过撤销可能未完成的事务的影响来修复数据库状态</p>
<p>仅更新记录&lt;T,X,v&gt;</p>
<p>事务T更改了数据库元素X，更改前的值为v</p>
<p>更新记录所反映的改变通常发生在主存中而不是磁盘上，即日志记录是对 WRITE 做出的反应，而不是对 OUTPUT 做出的反应</p>
<p>undo-logging rules:</p>
<ul>
<li>U1：如果事务 T 改变了数据库元素 X，那么形如 &lt;T, X, *v*&gt; 的日志记录必须在 X 的新值写到磁盘前写到磁盘</li>
<li>U2：如果事务提交，则其 COMMIT 日志记录必须在事务改变的所有数据库元素已写到磁盘后再写到磁盘，但应尽快</li>
</ul>
<p>必须按照以下顺序写入磁盘：</p>
<p>1.显示数据库元素发生变化的日志记录</p>
<p>2.变更后的元素本身</p>
<p>3.提交日志记录</p>
<p>为了强制将日志记录写到磁盘，日志记录需要一条刷新日志命令，告诉缓冲区管理器：将以前没有拷贝到磁盘的日志记录、从上一次拷贝以来已发生修改的日志记录拷贝到磁盘，FLUSH LOG</p>
<p>事务管理器需要告诉缓冲区管理器：在某个数据库元素上执行 OUTPUT 动作</p>
<h3 id="redo-logging"><a href="#redo-logging" class="headerlink" title="redo logging"></a>redo logging</h3><p>在事务修改数据后，将新值写入日志</p>
<p>延迟修改：数据修改后暂存内存，提交后批量写入磁盘</p>
<p>写入磁盘顺序：日志-&gt;COMMIT-&gt;数据</p>
<p>undo&#x2F;redo:同时记录旧值和新值</p>
<p>数据库恢复机制</p>
<p>undo&#x2F;redo模型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Redo 所有已提交事务（COMMIT）</strong></td>
<td>即使数据页已在内存或磁盘中，也要重做已提交事务的操作，确保持久性。</td>
</tr>
<tr>
<td><strong>Undo 所有未提交事务</strong></td>
<td>撤销所有未提交事务对数据库的修改（从日志中恢复“旧值”）</td>
</tr>
</tbody></table>
<p>恢复操作：日志回放，倒序扫描</p>
<p>追加日志：&lt;UNDO T1, B, 21, 20&gt;<br>&lt;UNDO T1, D, 41, 40&gt;<br><ABORT t1></ABORT></p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p><img src="/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/image-20250604191924848.png" alt="image-20250604191924848"></p>
<p>两个操作属于冲突操作，必须满足：</p>
<ol>
<li>它们作用于<strong>同一数据项</strong>；</li>
<li>它们<strong>至少一个是写操作</strong>；</li>
<li>它们属于<strong>不同的事务</strong></li>
</ol>
<table>
<thead>
<tr>
<th>概念</th>
<th>一句话定义</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td><strong>可串行化</strong></td>
<td>一个调度如果<strong>等价于某个串行执行的调度</strong>，就是可串行化。</td>
<td>强调效果一样</td>
</tr>
<tr>
<td><strong>冲突可串行化</strong></td>
<td>如果一个调度<strong>通过交换不冲突的操作可以变成某个串行调度</strong>，就是冲突可串行化。</td>
<td>强调操作顺序一样</td>
</tr>
</tbody></table>
<p>冲突可串行化是可串行化的子集</p>
<p>优先关系图</p>
<p>检查一个调度是不是冲突可串行化的。</p>
<p>结点：调度的事务，标下标</p>
<p>边：Ti → Tj，指 Ti 优先于 Tj，写做 Ti &lt; sTj，满足：</p>
<ul>
<li>Ti 的动作 A1、Tj 的动作 A2</li>
<li>调度 S 中 A1 在 A2 之前</li>
<li>A1 和 A2 涉及同一数据库元素，且二者中至少一个是写</li>
</ul>
<p>构建优先图，判断是否有环</p>
<p>二阶段锁协议要求：一个事务加锁和释放锁分为两个阶段，加完锁之后就不能再加锁，只能释放。</p>
<p>为什么二阶段锁有效？</p>
<p><strong>如果只有加锁阶段（没解锁）</strong> ⇒ 死锁、资源不释放；</p>
<p><strong>如果加锁和解锁随意交错</strong> ⇒ 事务可以“插队”改变本应串行的顺序 ⇒ 出现并发异常（脏读、不可重复读等）；</p>
<p>所以二阶段锁是实现串行化的<strong>恰好最小限制条件</strong>。</p>
<p>锁</p>
<p>共享锁（shared-lock):允许多个事务并发读取数据，不能修改数据</p>
<p>排他锁（exclusive lock):事务可以读写数据</p>
<p>更新锁（update lock):为了防止死锁设计，用于“读后写”的场景：先加更新锁，准备更新数据，等确认写时再升级为排他锁。</p>
<p>一个资源只能有一个更新锁，但与共享锁兼容。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xinyi234.github.io">xinyi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xinyi234.github.io/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">https://xinyi234.github.io/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xinyi234.github.io" target="_blank">Xinyi's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a></div><div class="post-share"><div class="social-share" data-image="/img/gudu1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="/img/gudu1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机网络</div></div><div class="info-2"><div class="info-item-1">2025.6.19 明天就考试了，怎么办怎么办(慌) 最基础的知识点了 往年题https://xyy9233.github.io/2024/12/16/ji-wang/  🥰伟大 第一章通常把与因特网相连的计算机或其他设备称为端系统，端系统也称为主机，主机分为客户和服务器 接入网是指将端系统物理连接到边缘路由器的网络，边缘路由器是端系统到任何其他远程端系统的路径的第一台路由器  家庭接入 企业接入 广域无线接入  网络核心：位于网络层级的最顶层，连接多个边缘网络 分组交换与电路交换   特性 分组交换 电路交换    连接类型 无连接（如IP网络）或...</div></div></div></a><a class="pagination-related" href="/2025/05/09/ISCC2025/" title="ISCC2025"><img class="cover" src="/img/gudu1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ISCC2025</div></div><div class="info-2"><div class="info-item-1">我好菜啊(大喊) 好好学习好好学习好好学习 re我要看小品其实这个程序是很明显的python打包的可执行文件，但是我没看出来，用ida看了好久用ai才知道，浪费了时间 看来python逆向还是没学好 在之前的博客中写了python逆向的基本流程，但是这道题用pyinstaller打包时加了密钥 参考链接：https://bbs.kanxue.com/thread-271253.htm 解出来的py源码： 1234567891011121314151617181920212223242526272829# uncompyle6 version 3.9.2# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.12.10 (tags/v3.12.10:0cc8128, Apr  8 2025, 12:21:36) [MSC v.1943 64 bit (AMD64)]# Embedded file name: something.pyimport mypy, yourpydef...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/17/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" title="算法设计"><img class="cover" src="/img/gudu2.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-17</div><div class="info-item-2">算法设计</div></div><div class="info-2"><div class="info-item-1">  ...</div></div></div></a><a class="pagination-related" href="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="/img/gudu1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-09</div><div class="info-item-2">计算机网络</div></div><div class="info-2"><div class="info-item-1">2025.6.19 明天就考试了，怎么办怎么办(慌) 最基础的知识点了 往年题https://xyy9233.github.io/2024/12/16/ji-wang/  🥰伟大 第一章通常把与因特网相连的计算机或其他设备称为端系统，端系统也称为主机，主机分为客户和服务器 接入网是指将端系统物理连接到边缘路由器的网络，边缘路由器是端系统到任何其他远程端系统的路径的第一台路由器  家庭接入 企业接入 广域无线接入  网络核心：位于网络层级的最顶层，连接多个边缘网络 分组交换与电路交换   特性 分组交换 电路交换    连接类型 无连接（如IP网络）或...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xinyi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xinyi234"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xinyi234" target="_blank" title="Github"><i class="fab fa-github" style="color: #ffffff;"></i></a><a class="social-icon" href="mailto:lijialin8917@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #ffffff;"></i></a><a class="social-icon" href="/3630016869" target="_blank" title="QQ"><i class="fa fa-qq" style="color: #ffffff;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">关系数据模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">关系数据库语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">关系代数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subquery%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">Subquery子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modification"><span class="toc-number">1.2.3.</span> <span class="toc-text">Modification</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA"><span class="toc-number">1.3.</span> <span class="toc-text">关系数据库设计理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96FD"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数依赖FD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96MVD"><span class="toc-number">1.3.3.</span> <span class="toc-text">多值依赖MVD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ER%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">ER模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#E-R%E5%9B%BE"><span class="toc-number">1.4.1.</span> <span class="toc-text">E&#x2F;R图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">约束与触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">触发器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.</span> <span class="toc-text">视图和索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%89%E5%85%A8"><span class="toc-number">1.7.</span> <span class="toc-text">服务器和安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">三层体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PSM"><span class="toc-number">1.7.2.</span> <span class="toc-text">PSM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83"><span class="toc-number">1.7.3.</span> <span class="toc-text">用户授权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D"><span class="toc-number">1.8.</span> <span class="toc-text">数据库恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-logging"><span class="toc-number">1.8.2.</span> <span class="toc-text">undo logging</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-logging"><span class="toc-number">1.8.3.</span> <span class="toc-text">redo logging</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.9.</span> <span class="toc-text">并发控制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" title="算法设计"><img src="/img/gudu2.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法设计"/></a><div class="content"><a class="title" href="/2025/06/17/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/" title="算法设计">算法设计</a><time datetime="2025-06-17T12:21:03.000Z" title="发表于 2025-06-17 20:21:03">2025-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/13/%E4%BA%91%E9%95%9C-Initial/" title="云镜-Initial"><img src="/img/gudu1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="云镜-Initial"/></a><div class="content"><a class="title" href="/2025/06/13/%E4%BA%91%E9%95%9C-Initial/" title="云镜-Initial">云镜-Initial</a><time datetime="2025-06-13T08:59:59.000Z" title="发表于 2025-06-13 16:59:59">2025-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="/img/gudu1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2025/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2025-06-09T05:46:44.000Z" title="发表于 2025-06-09 13:46:44">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" title="数据库系统"><img src="/img/gudu1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库系统"/></a><div class="content"><a class="title" href="/2025/06/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" title="数据库系统">数据库系统</a><time datetime="2025-06-03T06:06:11.000Z" title="发表于 2025-06-03 14:06:11">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/09/ISCC2025/" title="ISCC2025"><img src="/img/gudu1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ISCC2025"/></a><div class="content"><a class="title" href="/2025/05/09/ISCC2025/" title="ISCC2025">ISCC2025</a><time datetime="2025-05-09T00:45:27.000Z" title="发表于 2025-05-09 08:45:27">2025-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By xinyi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script></div></body></html>